/* automatically generated by rust-bindgen */

#[repr(C)]
pub struct __BindgenUnionField<T>(::std::marker::PhantomData<T>);
impl <T> __BindgenUnionField<T> {
    #[inline]
    pub fn new() -> Self { __BindgenUnionField(::std::marker::PhantomData) }
    #[inline]
    pub unsafe fn as_ref(&self) -> &T { ::std::mem::transmute(self) }
    #[inline]
    pub unsafe fn as_mut(&mut self) -> &mut T { ::std::mem::transmute(self) }
}
impl <T> ::std::default::Default for __BindgenUnionField<T> {
    #[inline]
    fn default() -> Self { Self::new() }
}
impl <T> ::std::clone::Clone for __BindgenUnionField<T> {
    #[inline]
    fn clone(&self) -> Self { Self::new() }
}
impl <T> ::std::marker::Copy for __BindgenUnionField<T> { }
impl <T> ::std::fmt::Debug for __BindgenUnionField<T> {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        fmt.write_str("__BindgenUnionField")
    }
}
pub const __GNUC_VA_LIST: ::libc::c_uint = 1;
pub const _LIBC_LIMITS_H_: ::libc::c_uint = 1;
pub const _FEATURES_H: ::libc::c_uint = 1;
pub const _DEFAULT_SOURCE: ::libc::c_uint = 1;
pub const __USE_ISOC11: ::libc::c_uint = 1;
pub const __USE_ISOC99: ::libc::c_uint = 1;
pub const __USE_ISOC95: ::libc::c_uint = 1;
pub const __USE_POSIX_IMPLICITLY: ::libc::c_uint = 1;
pub const _POSIX_SOURCE: ::libc::c_uint = 1;
pub const _POSIX_C_SOURCE: ::libc::c_uint = 200809;
pub const __USE_POSIX: ::libc::c_uint = 1;
pub const __USE_POSIX2: ::libc::c_uint = 1;
pub const __USE_POSIX199309: ::libc::c_uint = 1;
pub const __USE_POSIX199506: ::libc::c_uint = 1;
pub const __USE_XOPEN2K: ::libc::c_uint = 1;
pub const __USE_XOPEN2K8: ::libc::c_uint = 1;
pub const _ATFILE_SOURCE: ::libc::c_uint = 1;
pub const __USE_MISC: ::libc::c_uint = 1;
pub const __USE_ATFILE: ::libc::c_uint = 1;
pub const __USE_FORTIFY_LEVEL: ::libc::c_uint = 0;
pub const _STDC_PREDEF_H: ::libc::c_uint = 1;
pub const __STDC_IEC_559__: ::libc::c_uint = 1;
pub const __STDC_IEC_559_COMPLEX__: ::libc::c_uint = 1;
pub const __STDC_ISO_10646__: ::libc::c_uint = 201505;
pub const __STDC_NO_THREADS__: ::libc::c_uint = 1;
pub const __GNU_LIBRARY__: ::libc::c_uint = 6;
pub const __GLIBC__: ::libc::c_uint = 2;
pub const __GLIBC_MINOR__: ::libc::c_uint = 24;
pub const _SYS_CDEFS_H: ::libc::c_uint = 1;
pub const __WORDSIZE: ::libc::c_uint = 64;
pub const __WORDSIZE_TIME64_COMPAT32: ::libc::c_uint = 1;
pub const __SYSCALL_WORDSIZE: ::libc::c_uint = 64;
pub const MB_LEN_MAX: ::libc::c_uint = 16;
pub const _BITS_POSIX1_LIM_H: ::libc::c_uint = 1;
pub const _POSIX_AIO_LISTIO_MAX: ::libc::c_uint = 2;
pub const _POSIX_AIO_MAX: ::libc::c_uint = 1;
pub const _POSIX_ARG_MAX: ::libc::c_uint = 4096;
pub const _POSIX_CHILD_MAX: ::libc::c_uint = 25;
pub const _POSIX_DELAYTIMER_MAX: ::libc::c_uint = 32;
pub const _POSIX_HOST_NAME_MAX: ::libc::c_uint = 255;
pub const _POSIX_LINK_MAX: ::libc::c_uint = 8;
pub const _POSIX_LOGIN_NAME_MAX: ::libc::c_uint = 9;
pub const _POSIX_MAX_CANON: ::libc::c_uint = 255;
pub const _POSIX_MAX_INPUT: ::libc::c_uint = 255;
pub const _POSIX_MQ_OPEN_MAX: ::libc::c_uint = 8;
pub const _POSIX_MQ_PRIO_MAX: ::libc::c_uint = 32;
pub const _POSIX_NAME_MAX: ::libc::c_uint = 14;
pub const _POSIX_NGROUPS_MAX: ::libc::c_uint = 8;
pub const _POSIX_OPEN_MAX: ::libc::c_uint = 20;
pub const _POSIX_PATH_MAX: ::libc::c_uint = 256;
pub const _POSIX_PIPE_BUF: ::libc::c_uint = 512;
pub const _POSIX_RE_DUP_MAX: ::libc::c_uint = 255;
pub const _POSIX_RTSIG_MAX: ::libc::c_uint = 8;
pub const _POSIX_SEM_NSEMS_MAX: ::libc::c_uint = 256;
pub const _POSIX_SEM_VALUE_MAX: ::libc::c_uint = 32767;
pub const _POSIX_SIGQUEUE_MAX: ::libc::c_uint = 32;
pub const _POSIX_SSIZE_MAX: ::libc::c_uint = 32767;
pub const _POSIX_STREAM_MAX: ::libc::c_uint = 8;
pub const _POSIX_SYMLINK_MAX: ::libc::c_uint = 255;
pub const _POSIX_SYMLOOP_MAX: ::libc::c_uint = 8;
pub const _POSIX_TIMER_MAX: ::libc::c_uint = 32;
pub const _POSIX_TTY_NAME_MAX: ::libc::c_uint = 9;
pub const _POSIX_TZNAME_MAX: ::libc::c_uint = 6;
pub const _POSIX_CLOCKRES_MIN: ::libc::c_uint = 20000000;
pub const NR_OPEN: ::libc::c_uint = 1024;
pub const NGROUPS_MAX: ::libc::c_uint = 65536;
pub const ARG_MAX: ::libc::c_uint = 131072;
pub const LINK_MAX: ::libc::c_uint = 127;
pub const MAX_CANON: ::libc::c_uint = 255;
pub const MAX_INPUT: ::libc::c_uint = 255;
pub const NAME_MAX: ::libc::c_uint = 255;
pub const PATH_MAX: ::libc::c_uint = 4096;
pub const PIPE_BUF: ::libc::c_uint = 4096;
pub const XATTR_NAME_MAX: ::libc::c_uint = 255;
pub const XATTR_SIZE_MAX: ::libc::c_uint = 65536;
pub const XATTR_LIST_MAX: ::libc::c_uint = 65536;
pub const RTSIG_MAX: ::libc::c_uint = 32;
pub const _POSIX_THREAD_KEYS_MAX: ::libc::c_uint = 128;
pub const PTHREAD_KEYS_MAX: ::libc::c_uint = 1024;
pub const _POSIX_THREAD_DESTRUCTOR_ITERATIONS: ::libc::c_uint = 4;
pub const PTHREAD_DESTRUCTOR_ITERATIONS: ::libc::c_uint = 4;
pub const _POSIX_THREAD_THREADS_MAX: ::libc::c_uint = 64;
pub const AIO_PRIO_DELTA_MAX: ::libc::c_uint = 20;
pub const PTHREAD_STACK_MIN: ::libc::c_uint = 16384;
pub const DELAYTIMER_MAX: ::libc::c_uint = 2147483647;
pub const TTY_NAME_MAX: ::libc::c_uint = 32;
pub const LOGIN_NAME_MAX: ::libc::c_uint = 256;
pub const HOST_NAME_MAX: ::libc::c_uint = 64;
pub const MQ_PRIO_MAX: ::libc::c_uint = 32768;
pub const SEM_VALUE_MAX: ::libc::c_uint = 2147483647;
pub const _BITS_POSIX2_LIM_H: ::libc::c_uint = 1;
pub const _POSIX2_BC_BASE_MAX: ::libc::c_uint = 99;
pub const _POSIX2_BC_DIM_MAX: ::libc::c_uint = 2048;
pub const _POSIX2_BC_SCALE_MAX: ::libc::c_uint = 99;
pub const _POSIX2_BC_STRING_MAX: ::libc::c_uint = 1000;
pub const _POSIX2_COLL_WEIGHTS_MAX: ::libc::c_uint = 2;
pub const _POSIX2_EXPR_NEST_MAX: ::libc::c_uint = 32;
pub const _POSIX2_LINE_MAX: ::libc::c_uint = 2048;
pub const _POSIX2_RE_DUP_MAX: ::libc::c_uint = 255;
pub const _POSIX2_CHARCLASS_NAME_MAX: ::libc::c_uint = 14;
pub const BC_BASE_MAX: ::libc::c_uint = 99;
pub const BC_DIM_MAX: ::libc::c_uint = 2048;
pub const BC_SCALE_MAX: ::libc::c_uint = 99;
pub const BC_STRING_MAX: ::libc::c_uint = 1000;
pub const COLL_WEIGHTS_MAX: ::libc::c_uint = 255;
pub const EXPR_NEST_MAX: ::libc::c_uint = 32;
pub const LINE_MAX: ::libc::c_uint = 2048;
pub const CHARCLASS_NAME_MAX: ::libc::c_uint = 2048;
pub const RE_DUP_MAX: ::libc::c_uint = 32767;
pub const LUAI_BITSINT: ::libc::c_uint = 32;
pub const LUA_INT_INT: ::libc::c_uint = 1;
pub const LUA_INT_LONG: ::libc::c_uint = 2;
pub const LUA_INT_LONGLONG: ::libc::c_uint = 3;
pub const LUA_FLOAT_FLOAT: ::libc::c_uint = 1;
pub const LUA_FLOAT_DOUBLE: ::libc::c_uint = 2;
pub const LUA_FLOAT_LONGDOUBLE: ::libc::c_uint = 3;
pub const LUA_INT_TYPE: ::libc::c_uint = 3;
pub const LUA_FLOAT_TYPE: ::libc::c_uint = 2;
pub const LUA_ROOT: &'static [u8; 6usize] = b"/usr/\x00";
pub const LUA_DIRSEP: &'static [u8; 2usize] = b"/\x00";
pub const LUA_NUMBER_FRMLEN: &'static [u8; 1usize] = b"\x00";
pub const LUA_NUMBER_FMT: &'static [u8; 6usize] = b"%.14g\x00";
pub const LUA_INTEGER_FRMLEN: &'static [u8; 3usize] = b"ll\x00";
pub const _STDINT_H: ::libc::c_uint = 1;
pub const _BITS_WCHAR_H: ::libc::c_uint = 1;
pub const INT8_MIN: ::libc::c_int = -128;
pub const INT16_MIN: ::libc::c_int = -32768;
pub const INT32_MIN: ::libc::c_int = -2147483648;
pub const INT8_MAX: ::libc::c_uint = 127;
pub const INT16_MAX: ::libc::c_uint = 32767;
pub const INT32_MAX: ::libc::c_uint = 2147483647;
pub const UINT8_MAX: ::libc::c_uint = 255;
pub const UINT16_MAX: ::libc::c_uint = 65535;
pub const UINT32_MAX: ::libc::c_uint = 4294967295;
pub const INT_LEAST8_MIN: ::libc::c_int = -128;
pub const INT_LEAST16_MIN: ::libc::c_int = -32768;
pub const INT_LEAST32_MIN: ::libc::c_int = -2147483648;
pub const INT_LEAST8_MAX: ::libc::c_uint = 127;
pub const INT_LEAST16_MAX: ::libc::c_uint = 32767;
pub const INT_LEAST32_MAX: ::libc::c_uint = 2147483647;
pub const UINT_LEAST8_MAX: ::libc::c_uint = 255;
pub const UINT_LEAST16_MAX: ::libc::c_uint = 65535;
pub const UINT_LEAST32_MAX: ::libc::c_uint = 4294967295;
pub const INT_FAST8_MIN: ::libc::c_int = -128;
pub const INT_FAST16_MIN: ::libc::c_longlong = -9223372036854775808;
pub const INT_FAST32_MIN: ::libc::c_longlong = -9223372036854775808;
pub const INT_FAST8_MAX: ::libc::c_uint = 127;
pub const INT_FAST16_MAX: ::libc::c_ulonglong = 9223372036854775807;
pub const INT_FAST32_MAX: ::libc::c_ulonglong = 9223372036854775807;
pub const UINT_FAST8_MAX: ::libc::c_uint = 255;
pub const UINT_FAST16_MAX: ::libc::c_int = -1;
pub const UINT_FAST32_MAX: ::libc::c_int = -1;
pub const INTPTR_MIN: ::libc::c_longlong = -9223372036854775808;
pub const INTPTR_MAX: ::libc::c_ulonglong = 9223372036854775807;
pub const UINTPTR_MAX: ::libc::c_int = -1;
pub const PTRDIFF_MIN: ::libc::c_longlong = -9223372036854775808;
pub const PTRDIFF_MAX: ::libc::c_ulonglong = 9223372036854775807;
pub const SIG_ATOMIC_MIN: ::libc::c_int = -2147483648;
pub const SIG_ATOMIC_MAX: ::libc::c_uint = 2147483647;
pub const SIZE_MAX: ::libc::c_int = -1;
pub const WINT_MIN: ::libc::c_uint = 0;
pub const WINT_MAX: ::libc::c_uint = 4294967295;
pub const LUAI_MAXSTACK: ::libc::c_uint = 1000000;
pub const LUA_IDSIZE: ::libc::c_uint = 60;
pub const LUAL_BUFFERSIZE: ::libc::c_uint = 8192;
pub const LUA_VERSION_MAJOR: &'static [u8; 2usize] = b"5\x00";
pub const LUA_VERSION_MINOR: &'static [u8; 2usize] = b"3\x00";
pub const LUA_VERSION_NUM: ::libc::c_uint = 503;
pub const LUA_VERSION_RELEASE: &'static [u8; 2usize] = b"3\x00";
pub const LUA_VERSION: &'static [u8; 8usize] = b"Lua 5.3\x00";
pub const LUA_RELEASE: &'static [u8; 10usize] = b"Lua 5.3.3\x00";
pub const LUA_COPYRIGHT: &'static [u8; 52usize] =
    b"Lua 5.3.3  Copyright (C) 1994-2016 Lua.org, PUC-Rio\x00";
pub const LUA_AUTHORS: &'static [u8; 48usize] =
    b"R. Ierusalimschy, L. H. de Figueiredo, W. Celes\x00";
pub const LUA_SIGNATURE: &'static [u8; 5usize] = b"\x1bLua\x00";
pub const LUA_MULTRET: ::libc::c_int = -1;
pub const LUA_REGISTRYINDEX: ::libc::c_int = -1001000;
pub const LUA_OK: ::libc::c_uint = 0;
pub const LUA_YIELD: ::libc::c_uint = 1;
pub const LUA_ERRRUN: ::libc::c_uint = 2;
pub const LUA_ERRSYNTAX: ::libc::c_uint = 3;
pub const LUA_ERRMEM: ::libc::c_uint = 4;
pub const LUA_ERRGCMM: ::libc::c_uint = 5;
pub const LUA_ERRERR: ::libc::c_uint = 6;
pub const LUA_TNONE: ::libc::c_int = -1;
pub const LUA_TNIL: ::libc::c_uint = 0;
pub const LUA_TBOOLEAN: ::libc::c_uint = 1;
pub const LUA_TLIGHTUSERDATA: ::libc::c_uint = 2;
pub const LUA_TNUMBER: ::libc::c_uint = 3;
pub const LUA_TSTRING: ::libc::c_uint = 4;
pub const LUA_TTABLE: ::libc::c_uint = 5;
pub const LUA_TFUNCTION: ::libc::c_uint = 6;
pub const LUA_TUSERDATA: ::libc::c_uint = 7;
pub const LUA_TTHREAD: ::libc::c_uint = 8;
pub const LUA_NUMTAGS: ::libc::c_uint = 9;
pub const LUA_MINSTACK: ::libc::c_uint = 20;
pub const LUA_RIDX_MAINTHREAD: ::libc::c_uint = 1;
pub const LUA_RIDX_GLOBALS: ::libc::c_uint = 2;
pub const LUA_RIDX_LAST: ::libc::c_uint = 2;
pub const LUA_OPADD: ::libc::c_uint = 0;
pub const LUA_OPSUB: ::libc::c_uint = 1;
pub const LUA_OPMUL: ::libc::c_uint = 2;
pub const LUA_OPMOD: ::libc::c_uint = 3;
pub const LUA_OPPOW: ::libc::c_uint = 4;
pub const LUA_OPDIV: ::libc::c_uint = 5;
pub const LUA_OPIDIV: ::libc::c_uint = 6;
pub const LUA_OPBAND: ::libc::c_uint = 7;
pub const LUA_OPBOR: ::libc::c_uint = 8;
pub const LUA_OPBXOR: ::libc::c_uint = 9;
pub const LUA_OPSHL: ::libc::c_uint = 10;
pub const LUA_OPSHR: ::libc::c_uint = 11;
pub const LUA_OPUNM: ::libc::c_uint = 12;
pub const LUA_OPEQ: ::libc::c_uint = 0;
pub const LUA_OPLT: ::libc::c_uint = 1;
pub const LUA_GCSTOP: ::libc::c_uint = 0;
pub const LUA_GCRESTART: ::libc::c_uint = 1;
pub const LUA_GCCOLLECT: ::libc::c_uint = 2;
pub const LUA_GCCOUNT: ::libc::c_uint = 3;
pub const LUA_GCCOUNTB: ::libc::c_uint = 4;
pub const LUA_GCSTEP: ::libc::c_uint = 5;
pub const LUA_GCSETPAUSE: ::libc::c_uint = 6;
pub const LUA_GCSETSTEPMUL: ::libc::c_uint = 7;
pub const LUA_HOOKCALL: ::libc::c_uint = 0;
pub const LUA_HOOKRET: ::libc::c_uint = 1;
pub const LUA_HOOKLINE: ::libc::c_uint = 2;
pub const LUA_HOOKCOUNT: ::libc::c_uint = 3;
pub const LUA_HOOKTAILCALL: ::libc::c_uint = 4;
pub const LUA_MASKCALL: ::libc::c_uint = 1;
pub const LUA_MASKRET: ::libc::c_uint = 2;
pub const LUA_MASKLINE: ::libc::c_uint = 4;
pub const LUA_MASKCOUNT: ::libc::c_uint = 8;
pub const _STDIO_H: ::libc::c_uint = 1;
pub const _BITS_TYPES_H: ::libc::c_uint = 1;
pub const _BITS_TYPESIZES_H: ::libc::c_uint = 1;
pub const __OFF_T_MATCHES_OFF64_T: ::libc::c_uint = 1;
pub const __INO_T_MATCHES_INO64_T: ::libc::c_uint = 1;
pub const __FD_SETSIZE: ::libc::c_uint = 1024;
pub const __FILE_defined: ::libc::c_uint = 1;
pub const ____FILE_defined: ::libc::c_uint = 1;
pub const _G_config_h: ::libc::c_uint = 1;
pub const ____mbstate_t_defined: ::libc::c_uint = 1;
pub const _G_HAVE_MMAP: ::libc::c_uint = 1;
pub const _G_HAVE_MREMAP: ::libc::c_uint = 1;
pub const _G_IO_IO_FILE_VERSION: ::libc::c_uint = 131073;
pub const _G_BUFSIZ: ::libc::c_uint = 8192;
pub const _IO_BUFSIZ: ::libc::c_uint = 8192;
pub const _IO_UNIFIED_JUMPTABLES: ::libc::c_uint = 1;
pub const EOF: ::libc::c_int = -1;
pub const _IOS_INPUT: ::libc::c_uint = 1;
pub const _IOS_OUTPUT: ::libc::c_uint = 2;
pub const _IOS_ATEND: ::libc::c_uint = 4;
pub const _IOS_APPEND: ::libc::c_uint = 8;
pub const _IOS_TRUNC: ::libc::c_uint = 16;
pub const _IOS_NOCREATE: ::libc::c_uint = 32;
pub const _IOS_NOREPLACE: ::libc::c_uint = 64;
pub const _IOS_BIN: ::libc::c_uint = 128;
pub const _IO_MAGIC: ::libc::c_uint = 4222418944;
pub const _OLD_STDIO_MAGIC: ::libc::c_uint = 4206624768;
pub const _IO_MAGIC_MASK: ::libc::c_uint = 4294901760;
pub const _IO_USER_BUF: ::libc::c_uint = 1;
pub const _IO_UNBUFFERED: ::libc::c_uint = 2;
pub const _IO_NO_READS: ::libc::c_uint = 4;
pub const _IO_NO_WRITES: ::libc::c_uint = 8;
pub const _IO_EOF_SEEN: ::libc::c_uint = 16;
pub const _IO_ERR_SEEN: ::libc::c_uint = 32;
pub const _IO_DELETE_DONT_CLOSE: ::libc::c_uint = 64;
pub const _IO_LINKED: ::libc::c_uint = 128;
pub const _IO_IN_BACKUP: ::libc::c_uint = 256;
pub const _IO_LINE_BUF: ::libc::c_uint = 512;
pub const _IO_TIED_PUT_GET: ::libc::c_uint = 1024;
pub const _IO_CURRENTLY_PUTTING: ::libc::c_uint = 2048;
pub const _IO_IS_APPENDING: ::libc::c_uint = 4096;
pub const _IO_IS_FILEBUF: ::libc::c_uint = 8192;
pub const _IO_BAD_SEEN: ::libc::c_uint = 16384;
pub const _IO_USER_LOCK: ::libc::c_uint = 32768;
pub const _IO_FLAGS2_MMAP: ::libc::c_uint = 1;
pub const _IO_FLAGS2_NOTCANCEL: ::libc::c_uint = 2;
pub const _IO_FLAGS2_USER_WBUF: ::libc::c_uint = 8;
pub const _IO_SKIPWS: ::libc::c_uint = 1;
pub const _IO_LEFT: ::libc::c_uint = 2;
pub const _IO_RIGHT: ::libc::c_uint = 4;
pub const _IO_INTERNAL: ::libc::c_uint = 8;
pub const _IO_DEC: ::libc::c_uint = 16;
pub const _IO_OCT: ::libc::c_uint = 32;
pub const _IO_HEX: ::libc::c_uint = 64;
pub const _IO_SHOWBASE: ::libc::c_uint = 128;
pub const _IO_SHOWPOINT: ::libc::c_uint = 256;
pub const _IO_UPPERCASE: ::libc::c_uint = 512;
pub const _IO_SHOWPOS: ::libc::c_uint = 1024;
pub const _IO_SCIENTIFIC: ::libc::c_uint = 2048;
pub const _IO_FIXED: ::libc::c_uint = 4096;
pub const _IO_UNITBUF: ::libc::c_uint = 8192;
pub const _IO_STDIO: ::libc::c_uint = 16384;
pub const _IO_DONT_CLOSE: ::libc::c_uint = 32768;
pub const _IO_BOOLALPHA: ::libc::c_uint = 65536;
pub const _IOFBF: ::libc::c_uint = 0;
pub const _IOLBF: ::libc::c_uint = 1;
pub const _IONBF: ::libc::c_uint = 2;
pub const BUFSIZ: ::libc::c_uint = 8192;
pub const SEEK_SET: ::libc::c_uint = 0;
pub const SEEK_CUR: ::libc::c_uint = 1;
pub const SEEK_END: ::libc::c_uint = 2;
pub const P_tmpdir: &'static [u8; 5usize] = b"/tmp\x00";
pub const L_tmpnam: ::libc::c_uint = 20;
pub const TMP_MAX: ::libc::c_uint = 238328;
pub const FILENAME_MAX: ::libc::c_uint = 4096;
pub const L_ctermid: ::libc::c_uint = 9;
pub const FOPEN_MAX: ::libc::c_uint = 16;
pub const LUA_ERRFILE: ::libc::c_uint = 7;
pub const LUA_NOREF: ::libc::c_int = -2;
pub const LUA_FILEHANDLE: &'static [u8; 6usize] = b"FILE*\x00";
pub type va_list = __builtin_va_list;
pub type __gnuc_va_list = __builtin_va_list;
pub type wchar_t = ::libc::c_int;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct max_align_t {
    pub __clang_max_align_nonce1: ::libc::c_longlong,
    pub __clang_max_align_nonce2: f64,
}
#[test]
fn bindgen_test_layout_max_align_t() {
    assert_eq!(::std::mem::size_of::<max_align_t>() , 32usize , concat ! (
               "Size of: " , stringify ! ( max_align_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const max_align_t ) ) .
                __clang_max_align_nonce1 as * const _ as usize } , 0usize ,
                concat ! (
                "Alignment of field: " , stringify ! ( max_align_t ) , "::" ,
                stringify ! ( __clang_max_align_nonce1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const max_align_t ) ) .
                __clang_max_align_nonce2 as * const _ as usize } , 16usize ,
                concat ! (
                "Alignment of field: " , stringify ! ( max_align_t ) , "::" ,
                stringify ! ( __clang_max_align_nonce2 ) ));
}
impl Clone for max_align_t {
    fn clone(&self) -> Self { *self }
}
pub type int_least8_t = ::libc::c_char;
pub type int_least16_t = ::libc::c_short;
pub type int_least32_t = ::libc::c_int;
pub type int_least64_t = ::libc::c_long;
pub type uint_least8_t = ::libc::c_uchar;
pub type uint_least16_t = ::libc::c_ushort;
pub type uint_least32_t = ::libc::c_uint;
pub type uint_least64_t = ::libc::c_ulong;
pub type int_fast8_t = ::libc::c_char;
pub type int_fast16_t = ::libc::c_long;
pub type int_fast32_t = ::libc::c_long;
pub type int_fast64_t = ::libc::c_long;
pub type uint_fast8_t = ::libc::c_uchar;
pub type uint_fast16_t = ::libc::c_ulong;
pub type uint_fast32_t = ::libc::c_ulong;
pub type uint_fast64_t = ::libc::c_ulong;
pub type intmax_t = ::libc::c_long;
pub type uintmax_t = ::libc::c_ulong;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lua_State([u8; 0]);
pub type lua_Number = f64;
pub type lua_Integer = ::libc::c_longlong;
pub type lua_Unsigned = ::libc::c_ulonglong;
pub type lua_KContext = isize;
pub type lua_CFunction =
    ::std::option::Option<unsafe extern "C" fn(L: *mut lua_State)
                              -> ::libc::c_int>;
pub type lua_KFunction =
    ::std::option::Option<unsafe extern "C" fn(L: *mut lua_State,
                                               status: ::libc::c_int,
                                               ctx: lua_KContext)
                              -> ::libc::c_int>;
pub type lua_Reader =
    ::std::option::Option<unsafe extern "C" fn(L: *mut lua_State,
                                               ud: *mut ::libc::c_void,
                                               sz: *mut usize)
                              -> *const ::libc::c_char>;
pub type lua_Writer =
    ::std::option::Option<unsafe extern "C" fn(L: *mut lua_State,
                                               p: *const ::libc::c_void,
                                               sz: usize,
                                               ud: *mut ::libc::c_void)
                              -> ::libc::c_int>;
pub type lua_Alloc =
    ::std::option::Option<unsafe extern "C" fn(ud: *mut ::libc::c_void,
                                               ptr: *mut ::libc::c_void,
                                               osize: usize, nsize: usize)
                              -> *mut ::libc::c_void>;
extern "C" {
    #[link_name = "lua_ident"]
    pub static mut lua_ident: [::libc::c_char; 0usize];
}
extern "C" {
    pub fn lua_newstate(f: lua_Alloc, ud: *mut ::libc::c_void)
     -> *mut lua_State;
}
extern "C" {
    pub fn lua_close(L: *mut lua_State);
}
extern "C" {
    pub fn lua_newthread(L: *mut lua_State) -> *mut lua_State;
}
extern "C" {
    pub fn lua_atpanic(L: *mut lua_State, panicf: lua_CFunction)
     -> ::std::option::Option<unsafe extern "C" fn() -> ::libc::c_int>;
}
extern "C" {
    pub fn lua_version(L: *mut lua_State) -> *const f64;
}
extern "C" {
    pub fn lua_absindex(L: *mut lua_State, idx: ::libc::c_int)
     -> ::libc::c_int;
}
extern "C" {
    pub fn lua_gettop(L: *mut lua_State) -> ::libc::c_int;
}
extern "C" {
    pub fn lua_settop(L: *mut lua_State, idx: ::libc::c_int);
}
extern "C" {
    pub fn lua_pushvalue(L: *mut lua_State, idx: ::libc::c_int);
}
extern "C" {
    pub fn lua_rotate(L: *mut lua_State, idx: ::libc::c_int,
                      n: ::libc::c_int);
}
extern "C" {
    pub fn lua_copy(L: *mut lua_State, fromidx: ::libc::c_int,
                    toidx: ::libc::c_int);
}
extern "C" {
    pub fn lua_checkstack(L: *mut lua_State, n: ::libc::c_int)
     -> ::libc::c_int;
}
extern "C" {
    pub fn lua_xmove(from: *mut lua_State, to: *mut lua_State,
                     n: ::libc::c_int);
}
extern "C" {
    pub fn lua_isnumber(L: *mut lua_State, idx: ::libc::c_int)
     -> ::libc::c_int;
}
extern "C" {
    pub fn lua_isstring(L: *mut lua_State, idx: ::libc::c_int)
     -> ::libc::c_int;
}
extern "C" {
    pub fn lua_iscfunction(L: *mut lua_State, idx: ::libc::c_int)
     -> ::libc::c_int;
}
extern "C" {
    pub fn lua_isinteger(L: *mut lua_State, idx: ::libc::c_int)
     -> ::libc::c_int;
}
extern "C" {
    pub fn lua_isuserdata(L: *mut lua_State, idx: ::libc::c_int)
     -> ::libc::c_int;
}
extern "C" {
    pub fn lua_type(L: *mut lua_State, idx: ::libc::c_int) -> ::libc::c_int;
}
extern "C" {
    pub fn lua_typename(L: *mut lua_State, tp: ::libc::c_int)
     -> *const ::libc::c_char;
}
extern "C" {
    pub fn lua_tonumberx(L: *mut lua_State, idx: ::libc::c_int,
                         isnum: *mut ::libc::c_int) -> f64;
}
extern "C" {
    pub fn lua_tointegerx(L: *mut lua_State, idx: ::libc::c_int,
                          isnum: *mut ::libc::c_int) -> ::libc::c_longlong;
}
extern "C" {
    pub fn lua_toboolean(L: *mut lua_State, idx: ::libc::c_int)
     -> ::libc::c_int;
}
extern "C" {
    pub fn lua_tolstring(L: *mut lua_State, idx: ::libc::c_int,
                         len: *mut usize) -> *const ::libc::c_char;
}
extern "C" {
    pub fn lua_rawlen(L: *mut lua_State, idx: ::libc::c_int)
     -> ::libc::c_ulong;
}
extern "C" {
    pub fn lua_tocfunction(L: *mut lua_State, idx: ::libc::c_int)
     -> ::std::option::Option<unsafe extern "C" fn() -> ::libc::c_int>;
}
extern "C" {
    pub fn lua_touserdata(L: *mut lua_State, idx: ::libc::c_int)
     -> *mut ::libc::c_void;
}
extern "C" {
    pub fn lua_tothread(L: *mut lua_State, idx: ::libc::c_int)
     -> *mut lua_State;
}
extern "C" {
    pub fn lua_topointer(L: *mut lua_State, idx: ::libc::c_int)
     -> *const ::libc::c_void;
}
extern "C" {
    pub fn lua_arith(L: *mut lua_State, op: ::libc::c_int);
}
extern "C" {
    pub fn lua_rawequal(L: *mut lua_State, idx1: ::libc::c_int,
                        idx2: ::libc::c_int) -> ::libc::c_int;
}
extern "C" {
    pub fn lua_compare(L: *mut lua_State, idx1: ::libc::c_int,
                       idx2: ::libc::c_int, op: ::libc::c_int)
     -> ::libc::c_int;
}
extern "C" {
    pub fn lua_pushnil(L: *mut lua_State);
}
extern "C" {
    pub fn lua_pushnumber(L: *mut lua_State, n: lua_Number);
}
extern "C" {
    pub fn lua_pushinteger(L: *mut lua_State, n: lua_Integer);
}
extern "C" {
    pub fn lua_pushlstring(L: *mut lua_State, s: *const ::libc::c_char,
                           len: usize) -> *const ::libc::c_char;
}
extern "C" {
    pub fn lua_pushstring(L: *mut lua_State, s: *const ::libc::c_char)
     -> *const ::libc::c_char;
}
extern "C" {
    pub fn lua_pushvfstring(L: *mut lua_State, fmt: *const ::libc::c_char,
                            argp: *mut __va_list_tag)
     -> *const ::libc::c_char;
}
extern "C" {
    pub fn lua_pushfstring(L: *mut lua_State, fmt: *const ::libc::c_char, ...)
     -> *const ::libc::c_char;
}
extern "C" {
    pub fn lua_pushcclosure(L: *mut lua_State, fn_: lua_CFunction,
                            n: ::libc::c_int);
}
extern "C" {
    pub fn lua_pushboolean(L: *mut lua_State, b: ::libc::c_int);
}
extern "C" {
    pub fn lua_pushlightuserdata(L: *mut lua_State, p: *mut ::libc::c_void);
}
extern "C" {
    pub fn lua_pushthread(L: *mut lua_State) -> ::libc::c_int;
}
extern "C" {
    pub fn lua_getglobal(L: *mut lua_State, name: *const ::libc::c_char)
     -> ::libc::c_int;
}
extern "C" {
    pub fn lua_gettable(L: *mut lua_State, idx: ::libc::c_int)
     -> ::libc::c_int;
}
extern "C" {
    pub fn lua_getfield(L: *mut lua_State, idx: ::libc::c_int,
                        k: *const ::libc::c_char) -> ::libc::c_int;
}
extern "C" {
    pub fn lua_geti(L: *mut lua_State, idx: ::libc::c_int, n: lua_Integer)
     -> ::libc::c_int;
}
extern "C" {
    pub fn lua_rawget(L: *mut lua_State, idx: ::libc::c_int) -> ::libc::c_int;
}
extern "C" {
    pub fn lua_rawgeti(L: *mut lua_State, idx: ::libc::c_int, n: lua_Integer)
     -> ::libc::c_int;
}
extern "C" {
    pub fn lua_rawgetp(L: *mut lua_State, idx: ::libc::c_int,
                       p: *const ::libc::c_void) -> ::libc::c_int;
}
extern "C" {
    pub fn lua_createtable(L: *mut lua_State, narr: ::libc::c_int,
                           nrec: ::libc::c_int);
}
extern "C" {
    pub fn lua_newuserdata(L: *mut lua_State, sz: usize)
     -> *mut ::libc::c_void;
}
extern "C" {
    pub fn lua_getmetatable(L: *mut lua_State, objindex: ::libc::c_int)
     -> ::libc::c_int;
}
extern "C" {
    pub fn lua_getuservalue(L: *mut lua_State, idx: ::libc::c_int)
     -> ::libc::c_int;
}
extern "C" {
    pub fn lua_setglobal(L: *mut lua_State, name: *const ::libc::c_char);
}
extern "C" {
    pub fn lua_settable(L: *mut lua_State, idx: ::libc::c_int);
}
extern "C" {
    pub fn lua_setfield(L: *mut lua_State, idx: ::libc::c_int,
                        k: *const ::libc::c_char);
}
extern "C" {
    pub fn lua_seti(L: *mut lua_State, idx: ::libc::c_int, n: lua_Integer);
}
extern "C" {
    pub fn lua_rawset(L: *mut lua_State, idx: ::libc::c_int);
}
extern "C" {
    pub fn lua_rawseti(L: *mut lua_State, idx: ::libc::c_int, n: lua_Integer);
}
extern "C" {
    pub fn lua_rawsetp(L: *mut lua_State, idx: ::libc::c_int,
                       p: *const ::libc::c_void);
}
extern "C" {
    pub fn lua_setmetatable(L: *mut lua_State, objindex: ::libc::c_int)
     -> ::libc::c_int;
}
extern "C" {
    pub fn lua_setuservalue(L: *mut lua_State, idx: ::libc::c_int);
}
extern "C" {
    pub fn lua_callk(L: *mut lua_State, nargs: ::libc::c_int,
                     nresults: ::libc::c_int, ctx: lua_KContext,
                     k: lua_KFunction);
}
extern "C" {
    pub fn lua_pcallk(L: *mut lua_State, nargs: ::libc::c_int,
                      nresults: ::libc::c_int, errfunc: ::libc::c_int,
                      ctx: lua_KContext, k: lua_KFunction) -> ::libc::c_int;
}
extern "C" {
    pub fn lua_load(L: *mut lua_State, reader: lua_Reader,
                    dt: *mut ::libc::c_void, chunkname: *const ::libc::c_char,
                    mode: *const ::libc::c_char) -> ::libc::c_int;
}
extern "C" {
    pub fn lua_dump(L: *mut lua_State, writer: lua_Writer,
                    data: *mut ::libc::c_void, strip: ::libc::c_int)
     -> ::libc::c_int;
}
extern "C" {
    pub fn lua_yieldk(L: *mut lua_State, nresults: ::libc::c_int,
                      ctx: lua_KContext, k: lua_KFunction) -> ::libc::c_int;
}
extern "C" {
    pub fn lua_resume(L: *mut lua_State, from: *mut lua_State,
                      narg: ::libc::c_int) -> ::libc::c_int;
}
extern "C" {
    pub fn lua_status(L: *mut lua_State) -> ::libc::c_int;
}
extern "C" {
    pub fn lua_isyieldable(L: *mut lua_State) -> ::libc::c_int;
}
extern "C" {
    pub fn lua_gc(L: *mut lua_State, what: ::libc::c_int, data: ::libc::c_int)
     -> ::libc::c_int;
}
extern "C" {
    pub fn lua_error(L: *mut lua_State) -> ::libc::c_int;
}
extern "C" {
    pub fn lua_next(L: *mut lua_State, idx: ::libc::c_int) -> ::libc::c_int;
}
extern "C" {
    pub fn lua_concat(L: *mut lua_State, n: ::libc::c_int);
}
extern "C" {
    pub fn lua_len(L: *mut lua_State, idx: ::libc::c_int);
}
extern "C" {
    pub fn lua_stringtonumber(L: *mut lua_State, s: *const ::libc::c_char)
     -> ::libc::c_ulong;
}
extern "C" {
    pub fn lua_getallocf(L: *mut lua_State, ud: *mut *mut ::libc::c_void)
     -> ::std::option::Option<unsafe extern "C" fn() -> *mut ::libc::c_void>;
}
extern "C" {
    pub fn lua_setallocf(L: *mut lua_State, f: lua_Alloc,
                         ud: *mut ::libc::c_void);
}
#[repr(C)]
pub struct lua_Debug {
    pub event: ::libc::c_int,
    pub name: *const ::libc::c_char,
    pub namewhat: *const ::libc::c_char,
    pub what: *const ::libc::c_char,
    pub source: *const ::libc::c_char,
    pub currentline: ::libc::c_int,
    pub linedefined: ::libc::c_int,
    pub lastlinedefined: ::libc::c_int,
    pub nups: ::libc::c_uchar,
    pub nparams: ::libc::c_uchar,
    pub isvararg: ::libc::c_char,
    pub istailcall: ::libc::c_char,
    pub short_src: [::libc::c_char; 60usize],
    pub i_ci: *mut CallInfo,
}
#[test]
fn bindgen_test_layout_lua_Debug() {
    assert_eq!(::std::mem::size_of::<lua_Debug>() , 128usize , concat ! (
               "Size of: " , stringify ! ( lua_Debug ) ));
    assert_eq! (::std::mem::align_of::<lua_Debug>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( lua_Debug ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lua_Debug ) ) . event as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( lua_Debug ) , "::" ,
                stringify ! ( event ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lua_Debug ) ) . name as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( lua_Debug ) , "::" ,
                stringify ! ( name ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lua_Debug ) ) . namewhat as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( lua_Debug ) , "::" ,
                stringify ! ( namewhat ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lua_Debug ) ) . what as * const _ as
                usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( lua_Debug ) , "::" ,
                stringify ! ( what ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lua_Debug ) ) . source as * const _ as
                usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( lua_Debug ) , "::" ,
                stringify ! ( source ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lua_Debug ) ) . currentline as * const _
                as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( lua_Debug ) , "::" ,
                stringify ! ( currentline ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lua_Debug ) ) . linedefined as * const _
                as usize } , 44usize , concat ! (
                "Alignment of field: " , stringify ! ( lua_Debug ) , "::" ,
                stringify ! ( linedefined ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lua_Debug ) ) . lastlinedefined as *
                const _ as usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( lua_Debug ) , "::" ,
                stringify ! ( lastlinedefined ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lua_Debug ) ) . nups as * const _ as
                usize } , 52usize , concat ! (
                "Alignment of field: " , stringify ! ( lua_Debug ) , "::" ,
                stringify ! ( nups ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lua_Debug ) ) . nparams as * const _ as
                usize } , 53usize , concat ! (
                "Alignment of field: " , stringify ! ( lua_Debug ) , "::" ,
                stringify ! ( nparams ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lua_Debug ) ) . isvararg as * const _ as
                usize } , 54usize , concat ! (
                "Alignment of field: " , stringify ! ( lua_Debug ) , "::" ,
                stringify ! ( isvararg ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lua_Debug ) ) . istailcall as * const _
                as usize } , 55usize , concat ! (
                "Alignment of field: " , stringify ! ( lua_Debug ) , "::" ,
                stringify ! ( istailcall ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lua_Debug ) ) . short_src as * const _ as
                usize } , 56usize , concat ! (
                "Alignment of field: " , stringify ! ( lua_Debug ) , "::" ,
                stringify ! ( short_src ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lua_Debug ) ) . i_ci as * const _ as
                usize } , 120usize , concat ! (
                "Alignment of field: " , stringify ! ( lua_Debug ) , "::" ,
                stringify ! ( i_ci ) ));
}
pub type lua_Hook =
    ::std::option::Option<unsafe extern "C" fn(L: *mut lua_State,
                                               ar: *mut lua_Debug)>;
extern "C" {
    pub fn lua_getstack(L: *mut lua_State, level: ::libc::c_int,
                        ar: *mut lua_Debug) -> ::libc::c_int;
}
extern "C" {
    pub fn lua_getinfo(L: *mut lua_State, what: *const ::libc::c_char,
                       ar: *mut lua_Debug) -> ::libc::c_int;
}
extern "C" {
    pub fn lua_getlocal(L: *mut lua_State, ar: *const lua_Debug,
                        n: ::libc::c_int) -> *const ::libc::c_char;
}
extern "C" {
    pub fn lua_setlocal(L: *mut lua_State, ar: *const lua_Debug,
                        n: ::libc::c_int) -> *const ::libc::c_char;
}
extern "C" {
    pub fn lua_getupvalue(L: *mut lua_State, funcindex: ::libc::c_int,
                          n: ::libc::c_int) -> *const ::libc::c_char;
}
extern "C" {
    pub fn lua_setupvalue(L: *mut lua_State, funcindex: ::libc::c_int,
                          n: ::libc::c_int) -> *const ::libc::c_char;
}
extern "C" {
    pub fn lua_upvalueid(L: *mut lua_State, fidx: ::libc::c_int,
                         n: ::libc::c_int) -> *mut ::libc::c_void;
}
extern "C" {
    pub fn lua_upvaluejoin(L: *mut lua_State, fidx1: ::libc::c_int,
                           n1: ::libc::c_int, fidx2: ::libc::c_int,
                           n2: ::libc::c_int);
}
extern "C" {
    pub fn lua_sethook(L: *mut lua_State, func: lua_Hook, mask: ::libc::c_int,
                       count: ::libc::c_int);
}
extern "C" {
    pub fn lua_gethook(L: *mut lua_State)
     -> ::std::option::Option<unsafe extern "C" fn()>;
}
extern "C" {
    pub fn lua_gethookmask(L: *mut lua_State) -> ::libc::c_int;
}
extern "C" {
    pub fn lua_gethookcount(L: *mut lua_State) -> ::libc::c_int;
}
extern "C" {
    pub fn luaopen_base(L: *mut lua_State) -> ::libc::c_int;
}
extern "C" {
    pub fn luaopen_coroutine(L: *mut lua_State) -> ::libc::c_int;
}
extern "C" {
    pub fn luaopen_table(L: *mut lua_State) -> ::libc::c_int;
}
extern "C" {
    pub fn luaopen_io(L: *mut lua_State) -> ::libc::c_int;
}
extern "C" {
    pub fn luaopen_os(L: *mut lua_State) -> ::libc::c_int;
}
extern "C" {
    pub fn luaopen_string(L: *mut lua_State) -> ::libc::c_int;
}
extern "C" {
    pub fn luaopen_utf8(L: *mut lua_State) -> ::libc::c_int;
}
extern "C" {
    pub fn luaopen_bit32(L: *mut lua_State) -> ::libc::c_int;
}
extern "C" {
    pub fn luaopen_math(L: *mut lua_State) -> ::libc::c_int;
}
extern "C" {
    pub fn luaopen_debug(L: *mut lua_State) -> ::libc::c_int;
}
extern "C" {
    pub fn luaopen_package(L: *mut lua_State) -> ::libc::c_int;
}
extern "C" {
    pub fn luaL_openlibs(L: *mut lua_State);
}
pub type __u_char = ::libc::c_uchar;
pub type __u_short = ::libc::c_ushort;
pub type __u_int = ::libc::c_uint;
pub type __u_long = ::libc::c_ulong;
pub type __int8_t = ::libc::c_char;
pub type __uint8_t = ::libc::c_uchar;
pub type __int16_t = ::libc::c_short;
pub type __uint16_t = ::libc::c_ushort;
pub type __int32_t = ::libc::c_int;
pub type __uint32_t = ::libc::c_uint;
pub type __int64_t = ::libc::c_long;
pub type __uint64_t = ::libc::c_ulong;
pub type __quad_t = ::libc::c_long;
pub type __u_quad_t = ::libc::c_ulong;
pub type __dev_t = ::libc::c_ulong;
pub type __uid_t = ::libc::c_uint;
pub type __gid_t = ::libc::c_uint;
pub type __ino_t = ::libc::c_ulong;
pub type __ino64_t = ::libc::c_ulong;
pub type __mode_t = ::libc::c_uint;
pub type __nlink_t = ::libc::c_ulong;
pub type __off_t = ::libc::c_long;
pub type __off64_t = ::libc::c_long;
pub type __pid_t = ::libc::c_int;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct __fsid_t {
    pub __val: [::libc::c_int; 2usize],
}
#[test]
fn bindgen_test_layout___fsid_t() {
    assert_eq!(::std::mem::size_of::<__fsid_t>() , 8usize , concat ! (
               "Size of: " , stringify ! ( __fsid_t ) ));
    assert_eq! (::std::mem::align_of::<__fsid_t>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( __fsid_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __fsid_t ) ) . __val as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( __fsid_t ) , "::" ,
                stringify ! ( __val ) ));
}
impl Clone for __fsid_t {
    fn clone(&self) -> Self { *self }
}
pub type __clock_t = ::libc::c_long;
pub type __rlim_t = ::libc::c_ulong;
pub type __rlim64_t = ::libc::c_ulong;
pub type __id_t = ::libc::c_uint;
pub type __time_t = ::libc::c_long;
pub type __useconds_t = ::libc::c_uint;
pub type __suseconds_t = ::libc::c_long;
pub type __daddr_t = ::libc::c_int;
pub type __key_t = ::libc::c_int;
pub type __clockid_t = ::libc::c_int;
pub type __timer_t = *mut ::libc::c_void;
pub type __blksize_t = ::libc::c_long;
pub type __blkcnt_t = ::libc::c_long;
pub type __blkcnt64_t = ::libc::c_long;
pub type __fsblkcnt_t = ::libc::c_ulong;
pub type __fsblkcnt64_t = ::libc::c_ulong;
pub type __fsfilcnt_t = ::libc::c_ulong;
pub type __fsfilcnt64_t = ::libc::c_ulong;
pub type __fsword_t = ::libc::c_long;
pub type __ssize_t = ::libc::c_long;
pub type __syscall_slong_t = ::libc::c_long;
pub type __syscall_ulong_t = ::libc::c_ulong;
pub type __loff_t = __off64_t;
pub type __qaddr_t = *mut __quad_t;
pub type __caddr_t = *mut ::libc::c_char;
pub type __intptr_t = ::libc::c_long;
pub type __socklen_t = ::libc::c_uint;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _IO_FILE {
    pub _flags: ::libc::c_int,
    pub _IO_read_ptr: *mut ::libc::c_char,
    pub _IO_read_end: *mut ::libc::c_char,
    pub _IO_read_base: *mut ::libc::c_char,
    pub _IO_write_base: *mut ::libc::c_char,
    pub _IO_write_ptr: *mut ::libc::c_char,
    pub _IO_write_end: *mut ::libc::c_char,
    pub _IO_buf_base: *mut ::libc::c_char,
    pub _IO_buf_end: *mut ::libc::c_char,
    pub _IO_save_base: *mut ::libc::c_char,
    pub _IO_backup_base: *mut ::libc::c_char,
    pub _IO_save_end: *mut ::libc::c_char,
    pub _markers: *mut _IO_marker,
    pub _chain: *mut _IO_FILE,
    pub _fileno: ::libc::c_int,
    pub _flags2: ::libc::c_int,
    pub _old_offset: __off_t,
    pub _cur_column: ::libc::c_ushort,
    pub _vtable_offset: ::libc::c_char,
    pub _shortbuf: [::libc::c_char; 1usize],
    pub _lock: *mut _IO_lock_t,
    pub _offset: __off64_t,
    pub __pad1: *mut ::libc::c_void,
    pub __pad2: *mut ::libc::c_void,
    pub __pad3: *mut ::libc::c_void,
    pub __pad4: *mut ::libc::c_void,
    pub __pad5: usize,
    pub _mode: ::libc::c_int,
    pub _unused2: [::libc::c_char; 20usize],
}
#[test]
fn bindgen_test_layout__IO_FILE() {
    assert_eq!(::std::mem::size_of::<_IO_FILE>() , 216usize , concat ! (
               "Size of: " , stringify ! ( _IO_FILE ) ));
    assert_eq! (::std::mem::align_of::<_IO_FILE>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( _IO_FILE ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _IO_FILE ) ) . _flags as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( _IO_FILE ) , "::" ,
                stringify ! ( _flags ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _IO_FILE ) ) . _IO_read_ptr as * const _
                as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( _IO_FILE ) , "::" ,
                stringify ! ( _IO_read_ptr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _IO_FILE ) ) . _IO_read_end as * const _
                as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( _IO_FILE ) , "::" ,
                stringify ! ( _IO_read_end ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _IO_FILE ) ) . _IO_read_base as * const _
                as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( _IO_FILE ) , "::" ,
                stringify ! ( _IO_read_base ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _IO_FILE ) ) . _IO_write_base as * const
                _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( _IO_FILE ) , "::" ,
                stringify ! ( _IO_write_base ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _IO_FILE ) ) . _IO_write_ptr as * const _
                as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( _IO_FILE ) , "::" ,
                stringify ! ( _IO_write_ptr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _IO_FILE ) ) . _IO_write_end as * const _
                as usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( _IO_FILE ) , "::" ,
                stringify ! ( _IO_write_end ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _IO_FILE ) ) . _IO_buf_base as * const _
                as usize } , 56usize , concat ! (
                "Alignment of field: " , stringify ! ( _IO_FILE ) , "::" ,
                stringify ! ( _IO_buf_base ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _IO_FILE ) ) . _IO_buf_end as * const _
                as usize } , 64usize , concat ! (
                "Alignment of field: " , stringify ! ( _IO_FILE ) , "::" ,
                stringify ! ( _IO_buf_end ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _IO_FILE ) ) . _IO_save_base as * const _
                as usize } , 72usize , concat ! (
                "Alignment of field: " , stringify ! ( _IO_FILE ) , "::" ,
                stringify ! ( _IO_save_base ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _IO_FILE ) ) . _IO_backup_base as * const
                _ as usize } , 80usize , concat ! (
                "Alignment of field: " , stringify ! ( _IO_FILE ) , "::" ,
                stringify ! ( _IO_backup_base ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _IO_FILE ) ) . _IO_save_end as * const _
                as usize } , 88usize , concat ! (
                "Alignment of field: " , stringify ! ( _IO_FILE ) , "::" ,
                stringify ! ( _IO_save_end ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _IO_FILE ) ) . _markers as * const _ as
                usize } , 96usize , concat ! (
                "Alignment of field: " , stringify ! ( _IO_FILE ) , "::" ,
                stringify ! ( _markers ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _IO_FILE ) ) . _chain as * const _ as
                usize } , 104usize , concat ! (
                "Alignment of field: " , stringify ! ( _IO_FILE ) , "::" ,
                stringify ! ( _chain ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _IO_FILE ) ) . _fileno as * const _ as
                usize } , 112usize , concat ! (
                "Alignment of field: " , stringify ! ( _IO_FILE ) , "::" ,
                stringify ! ( _fileno ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _IO_FILE ) ) . _flags2 as * const _ as
                usize } , 116usize , concat ! (
                "Alignment of field: " , stringify ! ( _IO_FILE ) , "::" ,
                stringify ! ( _flags2 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _IO_FILE ) ) . _old_offset as * const _
                as usize } , 120usize , concat ! (
                "Alignment of field: " , stringify ! ( _IO_FILE ) , "::" ,
                stringify ! ( _old_offset ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _IO_FILE ) ) . _cur_column as * const _
                as usize } , 128usize , concat ! (
                "Alignment of field: " , stringify ! ( _IO_FILE ) , "::" ,
                stringify ! ( _cur_column ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _IO_FILE ) ) . _vtable_offset as * const
                _ as usize } , 130usize , concat ! (
                "Alignment of field: " , stringify ! ( _IO_FILE ) , "::" ,
                stringify ! ( _vtable_offset ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _IO_FILE ) ) . _shortbuf as * const _ as
                usize } , 131usize , concat ! (
                "Alignment of field: " , stringify ! ( _IO_FILE ) , "::" ,
                stringify ! ( _shortbuf ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _IO_FILE ) ) . _lock as * const _ as
                usize } , 136usize , concat ! (
                "Alignment of field: " , stringify ! ( _IO_FILE ) , "::" ,
                stringify ! ( _lock ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _IO_FILE ) ) . _offset as * const _ as
                usize } , 144usize , concat ! (
                "Alignment of field: " , stringify ! ( _IO_FILE ) , "::" ,
                stringify ! ( _offset ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _IO_FILE ) ) . __pad1 as * const _ as
                usize } , 152usize , concat ! (
                "Alignment of field: " , stringify ! ( _IO_FILE ) , "::" ,
                stringify ! ( __pad1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _IO_FILE ) ) . __pad2 as * const _ as
                usize } , 160usize , concat ! (
                "Alignment of field: " , stringify ! ( _IO_FILE ) , "::" ,
                stringify ! ( __pad2 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _IO_FILE ) ) . __pad3 as * const _ as
                usize } , 168usize , concat ! (
                "Alignment of field: " , stringify ! ( _IO_FILE ) , "::" ,
                stringify ! ( __pad3 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _IO_FILE ) ) . __pad4 as * const _ as
                usize } , 176usize , concat ! (
                "Alignment of field: " , stringify ! ( _IO_FILE ) , "::" ,
                stringify ! ( __pad4 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _IO_FILE ) ) . __pad5 as * const _ as
                usize } , 184usize , concat ! (
                "Alignment of field: " , stringify ! ( _IO_FILE ) , "::" ,
                stringify ! ( __pad5 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _IO_FILE ) ) . _mode as * const _ as
                usize } , 192usize , concat ! (
                "Alignment of field: " , stringify ! ( _IO_FILE ) , "::" ,
                stringify ! ( _mode ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _IO_FILE ) ) . _unused2 as * const _ as
                usize } , 196usize , concat ! (
                "Alignment of field: " , stringify ! ( _IO_FILE ) , "::" ,
                stringify ! ( _unused2 ) ));
}
impl Clone for _IO_FILE {
    fn clone(&self) -> Self { *self }
}
pub type FILE = _IO_FILE;
pub type __FILE = _IO_FILE;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct __mbstate_t {
    pub __count: ::libc::c_int,
    pub __value: __mbstate_t__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct __mbstate_t__bindgen_ty_1 {
    pub __wch: __BindgenUnionField<::libc::c_uint>,
    pub __wchb: __BindgenUnionField<[::libc::c_char; 4usize]>,
    pub bindgen_union_field: u32,
}
#[test]
fn bindgen_test_layout___mbstate_t__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<__mbstate_t__bindgen_ty_1>() , 4usize ,
               concat ! (
               "Size of: " , stringify ! ( __mbstate_t__bindgen_ty_1 ) ));
    assert_eq! (::std::mem::align_of::<__mbstate_t__bindgen_ty_1>() , 4usize ,
                concat ! (
                "Alignment of " , stringify ! ( __mbstate_t__bindgen_ty_1 )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __mbstate_t__bindgen_ty_1 ) ) . __wch as
                * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                __mbstate_t__bindgen_ty_1 ) , "::" , stringify ! ( __wch ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __mbstate_t__bindgen_ty_1 ) ) . __wchb as
                * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                __mbstate_t__bindgen_ty_1 ) , "::" , stringify ! ( __wchb )
                ));
}
impl Clone for __mbstate_t__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout___mbstate_t() {
    assert_eq!(::std::mem::size_of::<__mbstate_t>() , 8usize , concat ! (
               "Size of: " , stringify ! ( __mbstate_t ) ));
    assert_eq! (::std::mem::align_of::<__mbstate_t>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( __mbstate_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __mbstate_t ) ) . __count as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( __mbstate_t ) , "::" ,
                stringify ! ( __count ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __mbstate_t ) ) . __value as * const _ as
                usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( __mbstate_t ) , "::" ,
                stringify ! ( __value ) ));
}
impl Clone for __mbstate_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _G_fpos_t {
    pub __pos: __off_t,
    pub __state: __mbstate_t,
}
#[test]
fn bindgen_test_layout__G_fpos_t() {
    assert_eq!(::std::mem::size_of::<_G_fpos_t>() , 16usize , concat ! (
               "Size of: " , stringify ! ( _G_fpos_t ) ));
    assert_eq! (::std::mem::align_of::<_G_fpos_t>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( _G_fpos_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _G_fpos_t ) ) . __pos as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( _G_fpos_t ) , "::" ,
                stringify ! ( __pos ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _G_fpos_t ) ) . __state as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( _G_fpos_t ) , "::" ,
                stringify ! ( __state ) ));
}
impl Clone for _G_fpos_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _G_fpos64_t {
    pub __pos: __off64_t,
    pub __state: __mbstate_t,
}
#[test]
fn bindgen_test_layout__G_fpos64_t() {
    assert_eq!(::std::mem::size_of::<_G_fpos64_t>() , 16usize , concat ! (
               "Size of: " , stringify ! ( _G_fpos64_t ) ));
    assert_eq! (::std::mem::align_of::<_G_fpos64_t>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( _G_fpos64_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _G_fpos64_t ) ) . __pos as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( _G_fpos64_t ) , "::" ,
                stringify ! ( __pos ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _G_fpos64_t ) ) . __state as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( _G_fpos64_t ) , "::" ,
                stringify ! ( __state ) ));
}
impl Clone for _G_fpos64_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_jump_t([u8; 0]);
pub type _IO_lock_t = ::libc::c_void;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _IO_marker {
    pub _next: *mut _IO_marker,
    pub _sbuf: *mut _IO_FILE,
    pub _pos: ::libc::c_int,
}
#[test]
fn bindgen_test_layout__IO_marker() {
    assert_eq!(::std::mem::size_of::<_IO_marker>() , 24usize , concat ! (
               "Size of: " , stringify ! ( _IO_marker ) ));
    assert_eq! (::std::mem::align_of::<_IO_marker>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( _IO_marker ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _IO_marker ) ) . _next as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( _IO_marker ) , "::" ,
                stringify ! ( _next ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _IO_marker ) ) . _sbuf as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( _IO_marker ) , "::" ,
                stringify ! ( _sbuf ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _IO_marker ) ) . _pos as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( _IO_marker ) , "::" ,
                stringify ! ( _pos ) ));
}
impl Clone for _IO_marker {
    fn clone(&self) -> Self { *self }
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum __codecvt_result {
    __codecvt_ok = 0,
    __codecvt_partial = 1,
    __codecvt_error = 2,
    __codecvt_noconv = 3,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_FILE_plus([u8; 0]);
extern "C" {
    #[link_name = "_IO_2_1_stdin_"]
    pub static mut _IO_2_1_stdin_: _IO_FILE_plus;
}
extern "C" {
    #[link_name = "_IO_2_1_stdout_"]
    pub static mut _IO_2_1_stdout_: _IO_FILE_plus;
}
extern "C" {
    #[link_name = "_IO_2_1_stderr_"]
    pub static mut _IO_2_1_stderr_: _IO_FILE_plus;
}
pub type __io_read_fn =
    ::std::option::Option<unsafe extern "C" fn(__cookie: *mut ::libc::c_void,
                                               __buf: *mut ::libc::c_char,
                                               __nbytes: usize) -> __ssize_t>;
pub type __io_write_fn =
    ::std::option::Option<unsafe extern "C" fn(__cookie: *mut ::libc::c_void,
                                               __buf: *const ::libc::c_char,
                                               __n: usize) -> __ssize_t>;
pub type __io_seek_fn =
    ::std::option::Option<unsafe extern "C" fn(__cookie: *mut ::libc::c_void,
                                               __pos: *mut __off64_t,
                                               __w: ::libc::c_int)
                              -> ::libc::c_int>;
pub type __io_close_fn =
    ::std::option::Option<unsafe extern "C" fn(__cookie: *mut ::libc::c_void)
                              -> ::libc::c_int>;
extern "C" {
    pub fn __underflow(arg1: *mut _IO_FILE) -> ::libc::c_int;
}
extern "C" {
    pub fn __uflow(arg1: *mut _IO_FILE) -> ::libc::c_int;
}
extern "C" {
    pub fn __overflow(arg1: *mut _IO_FILE, arg2: ::libc::c_int)
     -> ::libc::c_int;
}
extern "C" {
    pub fn _IO_getc(__fp: *mut _IO_FILE) -> ::libc::c_int;
}
extern "C" {
    pub fn _IO_putc(__c: ::libc::c_int, __fp: *mut _IO_FILE) -> ::libc::c_int;
}
extern "C" {
    pub fn _IO_feof(__fp: *mut _IO_FILE) -> ::libc::c_int;
}
extern "C" {
    pub fn _IO_ferror(__fp: *mut _IO_FILE) -> ::libc::c_int;
}
extern "C" {
    pub fn _IO_peekc_locked(__fp: *mut _IO_FILE) -> ::libc::c_int;
}
extern "C" {
    pub fn _IO_flockfile(arg1: *mut _IO_FILE);
}
extern "C" {
    pub fn _IO_funlockfile(arg1: *mut _IO_FILE);
}
extern "C" {
    pub fn _IO_ftrylockfile(arg1: *mut _IO_FILE) -> ::libc::c_int;
}
extern "C" {
    pub fn _IO_vfscanf(arg1: *mut _IO_FILE, arg2: *const ::libc::c_char,
                       arg3: *mut __va_list_tag, arg4: *mut ::libc::c_int)
     -> ::libc::c_int;
}
extern "C" {
    pub fn _IO_vfprintf(arg1: *mut _IO_FILE, arg2: *const ::libc::c_char,
                        arg3: *mut __va_list_tag) -> ::libc::c_int;
}
extern "C" {
    pub fn _IO_padn(arg1: *mut _IO_FILE, arg2: ::libc::c_int, arg3: __ssize_t)
     -> __ssize_t;
}
extern "C" {
    pub fn _IO_sgetn(arg1: *mut _IO_FILE, arg2: *mut ::libc::c_void,
                     arg3: usize) -> usize;
}
extern "C" {
    pub fn _IO_seekoff(arg1: *mut _IO_FILE, arg2: __off64_t,
                       arg3: ::libc::c_int, arg4: ::libc::c_int) -> __off64_t;
}
extern "C" {
    pub fn _IO_seekpos(arg1: *mut _IO_FILE, arg2: __off64_t,
                       arg3: ::libc::c_int) -> __off64_t;
}
extern "C" {
    pub fn _IO_free_backup_area(arg1: *mut _IO_FILE);
}
pub type off_t = __off_t;
pub type fpos_t = _G_fpos_t;
extern "C" {
    #[link_name = "stdin"]
    pub static mut stdin: *mut _IO_FILE;
}
extern "C" {
    #[link_name = "stdout"]
    pub static mut stdout: *mut _IO_FILE;
}
extern "C" {
    #[link_name = "stderr"]
    pub static mut stderr: *mut _IO_FILE;
}
extern "C" {
    pub fn remove(__filename: *const ::libc::c_char) -> ::libc::c_int;
}
extern "C" {
    pub fn rename(__old: *const ::libc::c_char, __new: *const ::libc::c_char)
     -> ::libc::c_int;
}
extern "C" {
    pub fn renameat(__oldfd: ::libc::c_int, __old: *const ::libc::c_char,
                    __newfd: ::libc::c_int, __new: *const ::libc::c_char)
     -> ::libc::c_int;
}
extern "C" {
    pub fn tmpfile() -> *mut FILE;
}
extern "C" {
    pub fn tmpnam(__s: *mut ::libc::c_char) -> *mut ::libc::c_char;
}
extern "C" {
    pub fn tmpnam_r(__s: *mut ::libc::c_char) -> *mut ::libc::c_char;
}
extern "C" {
    pub fn tempnam(__dir: *const ::libc::c_char, __pfx: *const ::libc::c_char)
     -> *mut ::libc::c_char;
}
extern "C" {
    pub fn fclose(__stream: *mut FILE) -> ::libc::c_int;
}
extern "C" {
    pub fn fflush(__stream: *mut FILE) -> ::libc::c_int;
}
extern "C" {
    pub fn fflush_unlocked(__stream: *mut FILE) -> ::libc::c_int;
}
extern "C" {
    pub fn fopen(__filename: *const ::libc::c_char,
                 __modes: *const ::libc::c_char) -> *mut FILE;
}
extern "C" {
    pub fn freopen(__filename: *const ::libc::c_char,
                   __modes: *const ::libc::c_char, __stream: *mut FILE)
     -> *mut FILE;
}
extern "C" {
    pub fn fdopen(__fd: ::libc::c_int, __modes: *const ::libc::c_char)
     -> *mut FILE;
}
extern "C" {
    pub fn fmemopen(__s: *mut ::libc::c_void, __len: usize,
                    __modes: *const ::libc::c_char) -> *mut FILE;
}
extern "C" {
    pub fn open_memstream(__bufloc: *mut *mut ::libc::c_char,
                          __sizeloc: *mut usize) -> *mut FILE;
}
extern "C" {
    pub fn setbuf(__stream: *mut FILE, __buf: *mut ::libc::c_char);
}
extern "C" {
    pub fn setvbuf(__stream: *mut FILE, __buf: *mut ::libc::c_char,
                   __modes: ::libc::c_int, __n: usize) -> ::libc::c_int;
}
extern "C" {
    pub fn setbuffer(__stream: *mut FILE, __buf: *mut ::libc::c_char,
                     __size: usize);
}
extern "C" {
    pub fn setlinebuf(__stream: *mut FILE);
}
extern "C" {
    pub fn fprintf(__stream: *mut FILE, __format: *const ::libc::c_char, ...)
     -> ::libc::c_int;
}
extern "C" {
    pub fn printf(__format: *const ::libc::c_char, ...) -> ::libc::c_int;
}
extern "C" {
    pub fn sprintf(__s: *mut ::libc::c_char,
                   __format: *const ::libc::c_char, ...) -> ::libc::c_int;
}
extern "C" {
    pub fn vfprintf(__s: *mut FILE, __format: *const ::libc::c_char,
                    __arg: *mut __va_list_tag) -> ::libc::c_int;
}
extern "C" {
    pub fn vprintf(__format: *const ::libc::c_char, __arg: *mut __va_list_tag)
     -> ::libc::c_int;
}
extern "C" {
    pub fn vsprintf(__s: *mut ::libc::c_char, __format: *const ::libc::c_char,
                    __arg: *mut __va_list_tag) -> ::libc::c_int;
}
extern "C" {
    pub fn snprintf(__s: *mut ::libc::c_char, __maxlen: usize,
                    __format: *const ::libc::c_char, ...) -> ::libc::c_int;
}
extern "C" {
    pub fn vsnprintf(__s: *mut ::libc::c_char, __maxlen: usize,
                     __format: *const ::libc::c_char,
                     __arg: *mut __va_list_tag) -> ::libc::c_int;
}
extern "C" {
    pub fn vdprintf(__fd: ::libc::c_int, __fmt: *const ::libc::c_char,
                    __arg: *mut __va_list_tag) -> ::libc::c_int;
}
extern "C" {
    pub fn dprintf(__fd: ::libc::c_int, __fmt: *const ::libc::c_char, ...)
     -> ::libc::c_int;
}
extern "C" {
    pub fn fscanf(__stream: *mut FILE, __format: *const ::libc::c_char, ...)
     -> ::libc::c_int;
}
extern "C" {
    pub fn scanf(__format: *const ::libc::c_char, ...) -> ::libc::c_int;
}
extern "C" {
    pub fn sscanf(__s: *const ::libc::c_char,
                  __format: *const ::libc::c_char, ...) -> ::libc::c_int;
}
extern "C" {
    #[link_name = "__isoc99_fscanf"]
    pub fn fscanf1(__stream: *mut FILE, __format: *const ::libc::c_char, ...)
     -> ::libc::c_int;
}
extern "C" {
    #[link_name = "__isoc99_scanf"]
    pub fn scanf1(__format: *const ::libc::c_char, ...) -> ::libc::c_int;
}
extern "C" {
    #[link_name = "__isoc99_sscanf"]
    pub fn sscanf1(__s: *const ::libc::c_char,
                   __format: *const ::libc::c_char, ...) -> ::libc::c_int;
}
extern "C" {
    pub fn vfscanf(__s: *mut FILE, __format: *const ::libc::c_char,
                   __arg: *mut __va_list_tag) -> ::libc::c_int;
}
extern "C" {
    pub fn vscanf(__format: *const ::libc::c_char, __arg: *mut __va_list_tag)
     -> ::libc::c_int;
}
extern "C" {
    pub fn vsscanf(__s: *const ::libc::c_char,
                   __format: *const ::libc::c_char, __arg: *mut __va_list_tag)
     -> ::libc::c_int;
}
extern "C" {
    #[link_name = "__isoc99_vfscanf"]
    pub fn vfscanf1(__s: *mut FILE, __format: *const ::libc::c_char,
                    __arg: *mut __va_list_tag) -> ::libc::c_int;
}
extern "C" {
    #[link_name = "__isoc99_vscanf"]
    pub fn vscanf1(__format: *const ::libc::c_char, __arg: *mut __va_list_tag)
     -> ::libc::c_int;
}
extern "C" {
    #[link_name = "__isoc99_vsscanf"]
    pub fn vsscanf1(__s: *const ::libc::c_char,
                    __format: *const ::libc::c_char,
                    __arg: *mut __va_list_tag) -> ::libc::c_int;
}
extern "C" {
    pub fn fgetc(__stream: *mut FILE) -> ::libc::c_int;
}
extern "C" {
    pub fn getc(__stream: *mut FILE) -> ::libc::c_int;
}
extern "C" {
    pub fn getchar() -> ::libc::c_int;
}
extern "C" {
    pub fn getc_unlocked(__stream: *mut FILE) -> ::libc::c_int;
}
extern "C" {
    pub fn getchar_unlocked() -> ::libc::c_int;
}
extern "C" {
    pub fn fgetc_unlocked(__stream: *mut FILE) -> ::libc::c_int;
}
extern "C" {
    pub fn fputc(__c: ::libc::c_int, __stream: *mut FILE) -> ::libc::c_int;
}
extern "C" {
    pub fn putc(__c: ::libc::c_int, __stream: *mut FILE) -> ::libc::c_int;
}
extern "C" {
    pub fn putchar(__c: ::libc::c_int) -> ::libc::c_int;
}
extern "C" {
    pub fn fputc_unlocked(__c: ::libc::c_int, __stream: *mut FILE)
     -> ::libc::c_int;
}
extern "C" {
    pub fn putc_unlocked(__c: ::libc::c_int, __stream: *mut FILE)
     -> ::libc::c_int;
}
extern "C" {
    pub fn putchar_unlocked(__c: ::libc::c_int) -> ::libc::c_int;
}
extern "C" {
    pub fn getw(__stream: *mut FILE) -> ::libc::c_int;
}
extern "C" {
    pub fn putw(__w: ::libc::c_int, __stream: *mut FILE) -> ::libc::c_int;
}
extern "C" {
    pub fn fgets(__s: *mut ::libc::c_char, __n: ::libc::c_int,
                 __stream: *mut FILE) -> *mut ::libc::c_char;
}
extern "C" {
    pub fn __getdelim(__lineptr: *mut *mut ::libc::c_char, __n: *mut usize,
                      __delimiter: ::libc::c_int, __stream: *mut FILE)
     -> __ssize_t;
}
extern "C" {
    pub fn getdelim(__lineptr: *mut *mut ::libc::c_char, __n: *mut usize,
                    __delimiter: ::libc::c_int, __stream: *mut FILE)
     -> __ssize_t;
}
extern "C" {
    pub fn getline(__lineptr: *mut *mut ::libc::c_char, __n: *mut usize,
                   __stream: *mut FILE) -> __ssize_t;
}
extern "C" {
    pub fn fputs(__s: *const ::libc::c_char, __stream: *mut FILE)
     -> ::libc::c_int;
}
extern "C" {
    pub fn puts(__s: *const ::libc::c_char) -> ::libc::c_int;
}
extern "C" {
    pub fn ungetc(__c: ::libc::c_int, __stream: *mut FILE) -> ::libc::c_int;
}
extern "C" {
    pub fn fread(__ptr: *mut ::libc::c_void, __size: usize, __n: usize,
                 __stream: *mut FILE) -> usize;
}
extern "C" {
    pub fn fwrite(__ptr: *const ::libc::c_void, __size: usize, __n: usize,
                  __s: *mut FILE) -> usize;
}
extern "C" {
    pub fn fread_unlocked(__ptr: *mut ::libc::c_void, __size: usize,
                          __n: usize, __stream: *mut FILE) -> usize;
}
extern "C" {
    pub fn fwrite_unlocked(__ptr: *const ::libc::c_void, __size: usize,
                           __n: usize, __stream: *mut FILE) -> usize;
}
extern "C" {
    pub fn fseek(__stream: *mut FILE, __off: ::libc::c_long,
                 __whence: ::libc::c_int) -> ::libc::c_int;
}
extern "C" {
    pub fn ftell(__stream: *mut FILE) -> ::libc::c_long;
}
extern "C" {
    pub fn rewind(__stream: *mut FILE);
}
extern "C" {
    pub fn fseeko(__stream: *mut FILE, __off: __off_t,
                  __whence: ::libc::c_int) -> ::libc::c_int;
}
extern "C" {
    pub fn ftello(__stream: *mut FILE) -> __off_t;
}
extern "C" {
    pub fn fgetpos(__stream: *mut FILE, __pos: *mut fpos_t) -> ::libc::c_int;
}
extern "C" {
    pub fn fsetpos(__stream: *mut FILE, __pos: *const fpos_t)
     -> ::libc::c_int;
}
extern "C" {
    pub fn clearerr(__stream: *mut FILE);
}
extern "C" {
    pub fn feof(__stream: *mut FILE) -> ::libc::c_int;
}
extern "C" {
    pub fn ferror(__stream: *mut FILE) -> ::libc::c_int;
}
extern "C" {
    pub fn clearerr_unlocked(__stream: *mut FILE);
}
extern "C" {
    pub fn feof_unlocked(__stream: *mut FILE) -> ::libc::c_int;
}
extern "C" {
    pub fn ferror_unlocked(__stream: *mut FILE) -> ::libc::c_int;
}
extern "C" {
    pub fn perror(__s: *const ::libc::c_char);
}
extern "C" {
    #[link_name = "sys_nerr"]
    pub static mut sys_nerr: ::libc::c_int;
}
extern "C" {
    #[link_name = "sys_errlist"]
    pub static mut sys_errlist: [*const ::libc::c_char; 0usize];
}
extern "C" {
    pub fn fileno(__stream: *mut FILE) -> ::libc::c_int;
}
extern "C" {
    pub fn fileno_unlocked(__stream: *mut FILE) -> ::libc::c_int;
}
extern "C" {
    pub fn popen(__command: *const ::libc::c_char,
                 __modes: *const ::libc::c_char) -> *mut FILE;
}
extern "C" {
    pub fn pclose(__stream: *mut FILE) -> ::libc::c_int;
}
extern "C" {
    pub fn ctermid(__s: *mut ::libc::c_char) -> *mut ::libc::c_char;
}
extern "C" {
    pub fn flockfile(__stream: *mut FILE);
}
extern "C" {
    pub fn ftrylockfile(__stream: *mut FILE) -> ::libc::c_int;
}
extern "C" {
    pub fn funlockfile(__stream: *mut FILE);
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct luaL_Reg {
    pub name: *const ::libc::c_char,
    pub func: lua_CFunction,
}
#[test]
fn bindgen_test_layout_luaL_Reg() {
    assert_eq!(::std::mem::size_of::<luaL_Reg>() , 16usize , concat ! (
               "Size of: " , stringify ! ( luaL_Reg ) ));
    assert_eq! (::std::mem::align_of::<luaL_Reg>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( luaL_Reg ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const luaL_Reg ) ) . name as * const _ as usize
                } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( luaL_Reg ) , "::" ,
                stringify ! ( name ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const luaL_Reg ) ) . func as * const _ as usize
                } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( luaL_Reg ) , "::" ,
                stringify ! ( func ) ));
}
impl Clone for luaL_Reg {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    pub fn luaL_checkversion_(L: *mut lua_State, ver: lua_Number, sz: usize);
}
extern "C" {
    pub fn luaL_getmetafield(L: *mut lua_State, obj: ::libc::c_int,
                             e: *const ::libc::c_char) -> ::libc::c_int;
}
extern "C" {
    pub fn luaL_callmeta(L: *mut lua_State, obj: ::libc::c_int,
                         e: *const ::libc::c_char) -> ::libc::c_int;
}
extern "C" {
    pub fn luaL_tolstring(L: *mut lua_State, idx: ::libc::c_int,
                          len: *mut usize) -> *const ::libc::c_char;
}
extern "C" {
    pub fn luaL_argerror(L: *mut lua_State, arg: ::libc::c_int,
                         extramsg: *const ::libc::c_char) -> ::libc::c_int;
}
extern "C" {
    pub fn luaL_checklstring(L: *mut lua_State, arg: ::libc::c_int,
                             l: *mut usize) -> *const ::libc::c_char;
}
extern "C" {
    pub fn luaL_optlstring(L: *mut lua_State, arg: ::libc::c_int,
                           def: *const ::libc::c_char, l: *mut usize)
     -> *const ::libc::c_char;
}
extern "C" {
    pub fn luaL_checknumber(L: *mut lua_State, arg: ::libc::c_int) -> f64;
}
extern "C" {
    pub fn luaL_optnumber(L: *mut lua_State, arg: ::libc::c_int,
                          def: lua_Number) -> f64;
}
extern "C" {
    pub fn luaL_checkinteger(L: *mut lua_State, arg: ::libc::c_int)
     -> ::libc::c_longlong;
}
extern "C" {
    pub fn luaL_optinteger(L: *mut lua_State, arg: ::libc::c_int,
                           def: lua_Integer) -> ::libc::c_longlong;
}
extern "C" {
    pub fn luaL_checkstack(L: *mut lua_State, sz: ::libc::c_int,
                           msg: *const ::libc::c_char);
}
extern "C" {
    pub fn luaL_checktype(L: *mut lua_State, arg: ::libc::c_int,
                          t: ::libc::c_int);
}
extern "C" {
    pub fn luaL_checkany(L: *mut lua_State, arg: ::libc::c_int);
}
extern "C" {
    pub fn luaL_newmetatable(L: *mut lua_State, tname: *const ::libc::c_char)
     -> ::libc::c_int;
}
extern "C" {
    pub fn luaL_setmetatable(L: *mut lua_State, tname: *const ::libc::c_char);
}
extern "C" {
    pub fn luaL_testudata(L: *mut lua_State, ud: ::libc::c_int,
                          tname: *const ::libc::c_char)
     -> *mut ::libc::c_void;
}
extern "C" {
    pub fn luaL_checkudata(L: *mut lua_State, ud: ::libc::c_int,
                           tname: *const ::libc::c_char)
     -> *mut ::libc::c_void;
}
extern "C" {
    pub fn luaL_where(L: *mut lua_State, lvl: ::libc::c_int);
}
extern "C" {
    pub fn luaL_error(L: *mut lua_State, fmt: *const ::libc::c_char, ...)
     -> ::libc::c_int;
}
extern "C" {
    pub fn luaL_checkoption(L: *mut lua_State, arg: ::libc::c_int,
                            def: *const ::libc::c_char,
                            lst: *const *const ::libc::c_char)
     -> ::libc::c_int;
}
extern "C" {
    pub fn luaL_fileresult(L: *mut lua_State, stat: ::libc::c_int,
                           fname: *const ::libc::c_char) -> ::libc::c_int;
}
extern "C" {
    pub fn luaL_execresult(L: *mut lua_State, stat: ::libc::c_int)
     -> ::libc::c_int;
}
extern "C" {
    pub fn luaL_ref(L: *mut lua_State, t: ::libc::c_int) -> ::libc::c_int;
}
extern "C" {
    pub fn luaL_unref(L: *mut lua_State, t: ::libc::c_int,
                      ref_: ::libc::c_int);
}
extern "C" {
    pub fn luaL_loadfilex(L: *mut lua_State, filename: *const ::libc::c_char,
                          mode: *const ::libc::c_char) -> ::libc::c_int;
}
extern "C" {
    pub fn luaL_loadbufferx(L: *mut lua_State, buff: *const ::libc::c_char,
                            sz: usize, name: *const ::libc::c_char,
                            mode: *const ::libc::c_char) -> ::libc::c_int;
}
extern "C" {
    pub fn luaL_loadstring(L: *mut lua_State, s: *const ::libc::c_char)
     -> ::libc::c_int;
}
extern "C" {
    pub fn luaL_newstate() -> *mut lua_State;
}
extern "C" {
    pub fn luaL_len(L: *mut lua_State, idx: ::libc::c_int)
     -> ::libc::c_longlong;
}
extern "C" {
    pub fn luaL_gsub(L: *mut lua_State, s: *const ::libc::c_char,
                     p: *const ::libc::c_char, r: *const ::libc::c_char)
     -> *const ::libc::c_char;
}
extern "C" {
    pub fn luaL_setfuncs(L: *mut lua_State, l: *const luaL_Reg,
                         nup: ::libc::c_int);
}
extern "C" {
    pub fn luaL_getsubtable(L: *mut lua_State, idx: ::libc::c_int,
                            fname: *const ::libc::c_char) -> ::libc::c_int;
}
extern "C" {
    pub fn luaL_traceback(L: *mut lua_State, L1: *mut lua_State,
                          msg: *const ::libc::c_char, level: ::libc::c_int);
}
extern "C" {
    pub fn luaL_requiref(L: *mut lua_State, modname: *const ::libc::c_char,
                         openf: lua_CFunction, glb: ::libc::c_int);
}
#[repr(C)]
pub struct luaL_Buffer {
    pub b: *mut ::libc::c_char,
    pub size: usize,
    pub n: usize,
    pub L: *mut lua_State,
    pub initb: [::libc::c_char; 8192usize],
}
#[test]
fn bindgen_test_layout_luaL_Buffer() {
    assert_eq!(::std::mem::size_of::<luaL_Buffer>() , 8224usize , concat ! (
               "Size of: " , stringify ! ( luaL_Buffer ) ));
    assert_eq! (::std::mem::align_of::<luaL_Buffer>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( luaL_Buffer ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const luaL_Buffer ) ) . b as * const _ as usize
                } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( luaL_Buffer ) , "::" ,
                stringify ! ( b ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const luaL_Buffer ) ) . size as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( luaL_Buffer ) , "::" ,
                stringify ! ( size ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const luaL_Buffer ) ) . n as * const _ as usize
                } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( luaL_Buffer ) , "::" ,
                stringify ! ( n ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const luaL_Buffer ) ) . L as * const _ as usize
                } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( luaL_Buffer ) , "::" ,
                stringify ! ( L ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const luaL_Buffer ) ) . initb as * const _ as
                usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( luaL_Buffer ) , "::" ,
                stringify ! ( initb ) ));
}
extern "C" {
    pub fn luaL_buffinit(L: *mut lua_State, B: *mut luaL_Buffer);
}
extern "C" {
    pub fn luaL_prepbuffsize(B: *mut luaL_Buffer, sz: usize)
     -> *mut ::libc::c_char;
}
extern "C" {
    pub fn luaL_addlstring(B: *mut luaL_Buffer, s: *const ::libc::c_char,
                           l: usize);
}
extern "C" {
    pub fn luaL_addstring(B: *mut luaL_Buffer, s: *const ::libc::c_char);
}
extern "C" {
    pub fn luaL_addvalue(B: *mut luaL_Buffer);
}
extern "C" {
    pub fn luaL_pushresult(B: *mut luaL_Buffer);
}
extern "C" {
    pub fn luaL_pushresultsize(B: *mut luaL_Buffer, sz: usize);
}
extern "C" {
    pub fn luaL_buffinitsize(L: *mut lua_State, B: *mut luaL_Buffer,
                             sz: usize) -> *mut ::libc::c_char;
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct luaL_Stream {
    pub f: *mut FILE,
    pub closef: lua_CFunction,
}
#[test]
fn bindgen_test_layout_luaL_Stream() {
    assert_eq!(::std::mem::size_of::<luaL_Stream>() , 16usize , concat ! (
               "Size of: " , stringify ! ( luaL_Stream ) ));
    assert_eq! (::std::mem::align_of::<luaL_Stream>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( luaL_Stream ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const luaL_Stream ) ) . f as * const _ as usize
                } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( luaL_Stream ) , "::" ,
                stringify ! ( f ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const luaL_Stream ) ) . closef as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( luaL_Stream ) , "::" ,
                stringify ! ( closef ) ));
}
impl Clone for luaL_Stream {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct __va_list_tag {
    pub gp_offset: ::libc::c_uint,
    pub fp_offset: ::libc::c_uint,
    pub overflow_arg_area: *mut ::libc::c_void,
    pub reg_save_area: *mut ::libc::c_void,
}
#[test]
fn bindgen_test_layout___va_list_tag() {
    assert_eq!(::std::mem::size_of::<__va_list_tag>() , 24usize , concat ! (
               "Size of: " , stringify ! ( __va_list_tag ) ));
    assert_eq! (::std::mem::align_of::<__va_list_tag>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( __va_list_tag ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __va_list_tag ) ) . gp_offset as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( __va_list_tag ) , "::"
                , stringify ! ( gp_offset ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __va_list_tag ) ) . fp_offset as * const
                _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( __va_list_tag ) , "::"
                , stringify ! ( fp_offset ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __va_list_tag ) ) . overflow_arg_area as
                * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( __va_list_tag ) , "::"
                , stringify ! ( overflow_arg_area ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __va_list_tag ) ) . reg_save_area as *
                const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( __va_list_tag ) , "::"
                , stringify ! ( reg_save_area ) ));
}
impl Clone for __va_list_tag {
    fn clone(&self) -> Self { *self }
}
pub type __builtin_va_list = [__va_list_tag; 1usize];
#[repr(C)]
#[derive(Debug, Copy)]
pub struct CallInfo {
    pub _address: u8,
}
impl Clone for CallInfo {
    fn clone(&self) -> Self { *self }
}
